<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cgv: Namespace cgv::base</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00006.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Namespace <a class="el" href="a00684.html" title="the base namespace holds the base hierarchy, support for plugin registration and signals ...">cgv::base</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="baseSEC"></a>
Base Hierarchy</h1>
<p>Most toolkits and frameworks provide a common base class from which all classes are derived that can use features of the toolkit or framework. In the cgv framework this class is simply called "base" and lives in the namespace <a class="el" href="a00684.html" title="the base namespace holds the base hierarchy, support for plugin registration and signals ...">cgv::base</a>. The <a class="el" href="a00017.html">base</a> class provides support for</p>
<ul>
<li>reference counting of instances</li>
<li>type casts</li>
<li>self reflection of the members and methods and access to properties</li>
<li>registration by a plugin.</li>
</ul>
<p><em>Careful:</em> Although multiple inheritance is used heavily in the cgv framework, it is not allowed to inherit <a class="el" href="a00017.html">base</a> more than one time, what would lead to <b>object</b> <b>schizophrenia</b>. C++ does not allow to enforce this constraint, which therefore lies in the responsibility of the programmer. Please be aware of that!</p>
<p>Besides the <a class="el" href="a00017.html">base</a> class, the following derived classes extend its functionality:</p>
<ul>
<li><a class="el" href="a00037.html">named</a> ... support for a name stored for each instance</li>
<li><a class="el" href="a00038.html">node</a> ... extends the <a class="el" href="a00037.html">named</a> by a pointer to a parent instance</li>
<li><a class="el" href="a00033.html">group</a> ... extends <a class="el" href="a00038.html">node</a> by methods that allow to organize a list of child instances</li>
</ul>
<p>Theses classes already provide the functionality to construct doubly linked tree structures and singly linked acyclic graph structures.</p>
<p>The <a class="el" href="a00017.html">base</a> class has two more methods that can be used by derived classes in an arbitrary way:</p>
<ul>
<li><a class="el" href="a00017.html#a3e1dd0ff6fa2baf3dc2149d3acfecd45">update()</a> ... for example used by gui classes to post a redraw</li>
<li><a class="el" href="a00017.html#ac6d5779bddffb712b248eae674396a98">get_user_data()</a> ... for example by a gui implementation with a specific toolkit, returns the toolkit specific gui element instance</li>
</ul>
<h2><a class="anchor" id="baseRC"></a>
Reference Counting of Instances</h2>
<p>Dynamic memory management with malloc/free and new/delete is quite error prone in C and C++. Frequently memory leaks are caused by instances that are allocated but never deallocated again. To circumvent this problem smart pointers have been proposed that implement the concept of reference counting. Here a counter is attached to each allocated instance, which counts the number of pointers that reference the instance. The counter is incremented when a new pointer references the instance and decremented if the reference is removed. As soon as the counter is decreased to zero the instance is removed as it cannot be referenced anymore. Smart pointers are implemented in C++ as template classes that overload (re)implement the constructors, destructor and assignment operator such that reference counting is done automatically.</p>
<p>There are two choices of where to store the reference counter. Either directly as member of the instance or in an additionally allocated memory block. The first approach is faster and more memory efficent, but has the prerequisite that each instance provides a reference counter and that the access to the reference counter is provided to the smart pointer. In the cgv framework both reference counting approaches are supported. The first and more efficient one can be used by deriving a class from <a class="el" href="a00072.html">cgv::data::ref_counted</a>, which simply adds a reference counter to the members of the class. The smart pointers for both approaches are implemented in the <a class="el" href="a00073.html">cgv::data::ref_ptr</a> template, which takes the instance type as first template argument and a boolean parameter as second argument. The boolean parameter tells, whether the instance type is derived from <a class="el" href="a00072.html">cgv::data::ref_counted</a> or not.</p>
<p>The <a class="el" href="a00017.html">base</a> class is also derived from <a class="el" href="a00072.html">cgv::data::ref_counted</a> such that reference counting is the default approach for instances derived from <a class="el" href="a00017.html">base</a>. Therefore all headers corresponding to the types in the base hierarchy contain a declaration of the corresponding smart pointer type, i.e. <a class="el" href="a00684.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>, <a class="el" href="a00684.html#af525d4a6a81e7899a679e179ccbbab7b">node_ptr</a>, etc. Please <b>always</b> use these types to declare pointers to instances of types from the base hierarchy.</p>
<h2><a class="anchor" id="baseTC"></a>
Type Casts</h2>
<p>In C++ there is a very important type cast denoted <code>dynamic_cast</code> which attempts to cast an instance of type A to type B. If the instance is not derived from B, the dynamic type cast returns a null pointer. The common usage of the dynamic type cast operator is to perform casts to derived classes or to check whether an instance implements a given interface. In the cgv framework a lot of functionality works on <a class="el" href="a00684.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>s. For traversal of the tree / graph structures one often needs to know whether a base instance is actually a <a class="el" href="a00038.html">node</a> or even <a class="el" href="a00033.html">group</a> and has a parent or even children. Furthermore, the gui driver needs to know from an instance whether it provides a GUI or not. This is done deriving a class from for example <a class="el" href="a00038.html">node</a> and from the interface class <a class="el" href="a00095.html" title="derive from this class to provide a gui to the current viewer ">cgv::gui::provider</a>. The GUI driver can then use the dynamic type cast to <a class="el" href="a00095.html" title="derive from this class to provide a gui to the current viewer ">cgv::gui::provider</a> to check whether an instance provides a GUI.</p>
<p>The <a class="el" href="a00017.html">base</a> class provides special methods to simplify the dynamic type casts:</p>
<ul>
<li><a class="el" href="a00017.html#a6d2b95a4802d2a4fc33b556726e0656f">get_named()</a> ... use dynamic type cast to cast to <a class="el" href="a00684.html#a41ed99892cc76b1f339b9a0693bb0e1f">named_ptr</a></li>
<li><a class="el" href="a00017.html#ac5198433016d177ca57f4c24c3427eca">get_node()</a> ... use dynamic type cast to cast to <a class="el" href="a00684.html#af525d4a6a81e7899a679e179ccbbab7b">node_ptr</a></li>
<li><a class="el" href="a00017.html#acd6c94f5eb8784c955f687984cbb70ae">get_group()</a> ... use dynamic type cast to cast to <a class="el" href="a00684.html#aea49074b205caba6f6a72feb0ad8879b">group_ptr</a></li>
<li><a class="el" href="a00017.html#a465d1e143a091da84a346ea011b9af7b">cast&lt;T&gt;()</a> ... use dynamic type cast to cast to type cgv::data::ref_ptr&lt;T&gt;</li>
<li><a class="el" href="a00017.html#aa2b866151a23c63b3e8029849e71a796">get_interface&lt;T&gt;()</a> ... use dynamic type cast to cast to interface type <code>T*</code>, note that reference counting cannot be supported anymore as interface types are not derived from <a class="el" href="a00017.html">base</a>.</li>
<li><a class="el" href="a00017.html#ac42e389f2200c4e848c7a6684094fab6">get_const_interface&lt;T&gt;()</a> ... use dynamic type cast to cast to interface type <code>const</code> <code>T*</code>, note that reference counting cannot be supported anymore as interface types are not derived from <a class="el" href="a00017.html">base</a>.</li>
</ul>
<h2><a class="anchor" id="propInt"></a>
Property Interface</h2>
<p>In addition to the self reflection functionality a more general property interface is provided by the <a class="el" href="a00017.html">base</a> class. Properties can simply be class members or more complex configurations that influence more than one class member. Properties are accessed by their names and have only the basic types <code>bool</code>, <code>int</code> (8, 16, 32 or 64 bit), <code>float</code> (32 or 64 bit) or <code>string</code>. Automatic conversion rules between these types are provided such that each property can be queried in each of the available types.</p>
<p>The following methods can be used to access properties:</p>
<ul>
<li><a class="el" href="a00017.html#a5978e45464c3fdd3083426c4b21ed28a">get&lt;T&gt;()</a>... return a property in the type specified as template argument</li>
<li><a class="el" href="a00017.html#a1ff38549b7f5c57918898543e78a416d">set()</a>... set the property from a value whose type is automatically derived from the template parameter</li>
<li><a class="el" href="a00017.html#ad796aa58a0b7d9c52d724a99366f58ae">is_property()</a>... check if property of given name exists</li>
<li><a class="el" href="a00017.html#afbfaded48bb322a4b77350ca73c9e1a2">multi_set()</a>... set several properties from through a string of the form "name1=value1;name2=value2;..."</li>
</ul>
<p>The programmer has to overload the following methods in derived classes to provide access to properties:</p>
<ul>
<li>base::get_property_declarations() ... return a string containing a semicolon separated list of property declarations.</li>
<li>base::get_void() ... retrieve a property value and store it in a value pointed to by the passed void pointer</li>
<li>base::set_void() ... set a property from a value pointed to by the passed void pointer</li>
</ul>
<p>The class <a class="el" href="a00292.html">cgv::type::variant</a> can be used to access the arguments which are passed as arbitrary types. The default implementation of the property interface uses the method <a class="el" href="a00017.html#aa0fe4266b74ebe49de68faaab3ca7a7a">self_reflect()</a> to declare, get and set properties. Example implementations are found in the examples plugin for example in the header plugins/examples/simple_cube_8.h.</p>
<h2><a class="anchor" id="baseRG"></a>
Registration by a Plugin</h2>
<p>Instances of the classes derived from <a class="el" href="a00017.html">base</a> can be published to the application and to previously registered listeners by plugins through the registration facility describe in section <a class="el" href="a00006.html#Plugins">Registration Mechanism for Plugins</a>. The following two methods allow an instance to react to registration and unregistration:</p>
<ul>
<li>register() ... called by registration facility after instance has been registered at all listeners.</li>
<li><a class="el" href="a00017.html#a0b3db0f57373229e66422eeeb6750ebc">unregister()</a> ... called by registration facility after instance has been unregistered completely</li>
</ul>
<h1><a class="anchor" id="Plugins"></a>
Registration Mechanism for Plugins</h1>
<p>Plugins are compiled code modules that can be loaded at runtime. They are realized in C++ via shared libraries / dlls. Plugins typically contain implementations of interface classes defined in the cgv library such as specializations of image readers. Furthermore, plugins can contain resource files such as icons and images.</p>
<p>The most important task of a plugin is to tell the application by whom it is loaded, which that loads the plugin.</p>
<p>Plugins in cgv use the registration functionality implemented in <a class="el" href="a00587_source.html">cgv/base/register.h</a> and cgv/base/register.cxx to provide</p>
<ul>
<li>instances of implemented class,</li>
<li>factories for instances</li>
<li>test functions</li>
<li>registration listeners,</li>
<li>drivers (for example for the gui),</li>
<li>servers (for example for fonts or triggers) and</li>
<li>resource files such as image files, which are embedded into an executable of an application or into a plugin.</li>
<li>resource files can be embedded in binary format into an application or plugin by converting it with the <code>res_prep</code> tool to a cxx-file that can be compiled. This performs an automatic registration of the resource file, which can be accessed through the functions defined in the header cgv/data/import.h (see function <a class="el" href="a00684.html#a58329babf8d564819b20b0417e185cbf" title="register a resource file ">cgv::base::register_resource_file</a>). For resource files with the extensions "*.bmp;*.jpg;*.jpeg;*.png;*.tif;*.tiff" (defined in the file make/vs/cgv_rules.rules) the files only need to be present in the source directory and the makefile generation facility does the rest.</li>
</ul>
<p>Except of resource files all other registration entity must be of a class type that inherits <a class="el" href="a00017.html">cgv::base::base</a> exactly once. Specialized registration entities are marked as such by deriving them also from one of the classes (all declared in <a class="el" href="a00587_source.html">cgv/base/register.h</a>):</p>
<ul>
<li><a class="el" href="a00051.html" title="structure used to register a test function ">cgv::base::test</a>,</li>
<li><a class="el" href="a00025.html" title="interface for a factory that allows to create objects derived from cgv::base::base ...">cgv::base::factory</a>,</li>
<li><a class="el" href="a00043.html" title="interfaces that allows to listen to registration events. ">cgv::base::registration_listener</a>,</li>
<li><a class="el" href="a00024.html" title="interfaces that add several listeners and objects. ">cgv::base::driver</a>,</li>
<li><a class="el" href="a00048.html" title="interfaces that add provides very basic functionality. ">cgv::base::server</a></li>
</ul>
<p>Registration can be done for example in the <code>main</code> function of an application with the function cgv::base::register_object(object_ptr, options) taking two parameters - the to be registered object and an option string. The option string is used to steer where the object should be registered to and to allow specification of arbitrary registration parameters. For example when registering a factory, one can specify a menu text and a shortcut that are used by the standard viewer to integrate the factory into the menu structure.</p>
<p>When calling the <a class="el" href="a00684.html#a1905874c746070ebf84f61d40b190c9f" title="register an object. ">cgv::base::register_object</a> function, the object and option string are passed to all previously registered registration listeners with the method cgv::base::registration_listener::register_object(object,option). After registration the <a class="el" href="a00017.html#a2f074aea5bf4b0bfeb00845750d27623" title="overload to handle register events that is sent after the instance has been registered ...">cgv::base::base::on_register()</a> method of the registered object is called. This gives the object the opportunity to initialize itself knowing that it has been integrated into the gui and rendering structures.</p>
<p>As the programmer cannot know which registration listeners keep reference counted pointers to a registered object, the function <a class="el" href="a00684.html#a3f018980ef487ccc3665141f2a5d498f" title="unregister an object and send event to all currently registered registration listeners ...">cgv::base::unregister_object</a> is provided. Again all registered listeners are notified by their unregister_object method and afterwards the unregister() method of the object itself is called. The listeners must make sure to remove all reference counted pointers onto the object passed to their unregister_object() method. The object itself would unregister all objects created by itself in its unregister() method. Typically, unregistration of an object will cause it and all its dependent objects to be destroyed.</p>
<p>The dynamic version of the cgv_viewer allows to load plugins in form of shared libraries / dlls based on parsing the command line arguments or configuation files. The viewer uses the function <a class="el" href="a00684.html#a2149df336157ff36461d13373039603f" title="process the command line arguments: extract program name and load all plugins ">cgv::base::process_command_line_args</a> to process all commands specified on the command line and recursively in configuration files. As the <code>main</code> functions in shared libraries / dlls are not standardized, the register_object() function cannot be used in plugins to for registration. Instead one declares static instances of helper classes whose constructors are called when loading the shared library. The registration is then performed in the constructor of the helper class. The following helper classes are provided in <a class="el" href="a00587_source.html">cgv/base/register.h</a>:</p>
<ul>
<li>cgv::base::object_registration&lt;T&gt; ... registers an instance created with the default constructor. The constructor of the helper class also allows to specify an options string,</li>
<li>cgv::base::object_registration_1&lt;T,CA&gt; ... same as above but uses a constructor with one argument of type CA,</li>
<li>cgv::base::object_registration_2&lt;T,CA&gt; ... same as above but uses a constructor with two arguments of type CA1 and CA2,</li>
<li>cgv::base::factory_registration&lt;T&gt; ... registers a default implementation of a factory class that allows to create new instances during runtime. The constructor of the helper class has additional parameters for the type name of the created instances, whether the factory can generate only one instances at a time and the options for factory as well as created instance registration.</li>
<li>cgv::base::factory_registration_1&lt;T,CA&gt; ... see above</li>
<li>cgv::base::factory_registration_2&lt;T,CA1,CA2&gt; ... see above</li>
<li><a class="el" href="a00046.html" title="convenience class to register a resource file ">cgv::base::resource_file_registration</a> ... registeres a resource file, what is typically only used in source files automatically generated with the res_prep tool for resource files</li>
</ul>
<p>During loading a shared library the registration is automatically disabled with the function <a class="el" href="a00684.html#a45c1d8be70dc4acba79fb03cbb8d35e1" title="if registration is disable, all registration events are stored and sent at the momement when registra...">cgv::base::disable_registration()</a>. This is important as the construction of instances that demand for the loading of another shared library can cause a deadlock of the application. Instead in the disabled registration all registration events are cached and executed after loading of the shared library has been completed. The the <a class="el" href="a00684.html#ae2844a296a9f2dae6d53d020748a67b3" title="Enable registration (default is that registration is disabled). ">cgv::base::enable_registration()</a> function is called again and the objects are registered in the order server, driver, listerener and all the rest. Resource file registration on the other hand is unproblematic and not delayed. One can turn off the discarding of the registration events with the function <a class="el" href="a00684.html#ae339489c32783bdf6a5d52c1a7f4cfbc" title="disable cleanup of registration events (see enable_registration_event_cleanup). ">cgv::base::disable_registration_event_cleanup()</a>. This gives listeners of plugins that are read later access to previously registered objects and is the default in the standard cgv_viewer application.</p>
<p>Finally, one can turn on permanent registration by the function <a class="el" href="a00684.html#ae68ea86c82c22d1cd2ed1dfadf66fc01" title="register a registration listener that stores pointers to all registered objects ">cgv::base::enable_permanent_registration()</a> in order to keep a list of all registered objects. This list gives configuration files access to all registered objects and allows to set their members at program start. Also this option is enabled in the standard cgv_viewer application.</p>
<h2><a class="anchor" id="RegEx"></a>
Registration Example</h2>
<p>Suppose you have implemented a class <code>picker</code> in your plugin and want to register a new instance of type <code>picker</code> when your plugin is loaded. Then you simply add the following line to the cxx file where you implemented the <code>picker</code> class: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cgv/base/register.h&gt;</span></div>
<div class="line"><a class="code" href="a00040.html">cgv::base::object_registration&lt;picker&gt;</a> picker_registration(<span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> The argument to the <code>picker_registration</code> constructor is the option string passed to the register_object function and can be used to select a specific listener. For example if you have several windows that can integrate the gui of registered objects, you can select the parent window for your object by specifying the name of the parent window in then argument to the object registration contructor. If an empty string is specified, all listeners will register the object.</p>
<p>If you want to register a factory that can generate <code>picker</code> instances you use the following line instead: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cgv/base/register.h&gt;</span></div>
<div class="line"><a class="code" href="a00029.html">cgv::base::factory_registration&lt;picker&gt;</a> picker_registration(<span class="stringliteral">&quot;picker&quot;</span>, <span class="stringliteral">&quot;menu_text=\&quot;new/picker\&quot;;shortcut=&#39;P&#39;&quot;</span>);</div>
</div><!-- fragment --><p> This will add an entry into the "new" submenu of the main menu and allow you to create <code>pickers</code> with the &lt;Ctrl-P&gt; shortcut. If you want to allow only the creation of one instance of picker, the following line is your choice: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cgv/base/register.h&gt;</span></div>
<div class="line"><a class="code" href="a00029.html">cgv::base::factory_registration&lt;picker&gt;</a> picker_registration(<span class="stringliteral">&quot;picker&quot;</span>, <span class="stringliteral">&quot;menu_text=\&quot;new/picker\&quot;;shortcut=&#39;P&#39;&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p> In this signleton case pressing the shortcut &lt;Ctrl-P&gt; several times hides and shows your picker instance.</p>
<p>Finally, to add your own registration listener you use the object_registration helper class on a class derived by <a class="el" href="a00017.html">cgv::base::base</a> and <a class="el" href="a00043.html" title="interfaces that allows to listen to registration events. ">cgv::base::registration_listener</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 5 2019 15:06:49 for cgv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
