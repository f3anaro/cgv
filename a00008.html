<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cgv: Namespace cgv::signal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00008.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Namespace cgv::signal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="commSEC"></a>
Communication with Signals and Actions</h1>
<p>There are two main communication helpers in the cgv framework: signals and actions. A signal is a callback manager that can be used like a function. It has a signature and can be called like a function. It manages a list of callbacks to which functions, methods and instances with ()-operator can be added. An action on the other hand tells how to call the method of a given class. It stores the arguments that are passed to the method. An action is typically passed to a traversal algorithm or class that traverses a tree or acyclic graph built out of <a class="el" href="a00033.html">cgv::base::group</a> instances. On every instance it checks whether it has the type needed to call the method of the action and if yes calls this method with the arguments stored in the action.</p>
<p>Signals are often used in the gui framework to notify of events such as value change events or button press events. Actions are typically applied to a scene graph or the tree of drawables in the 3d view of the cgv_viewer, for example to init or draw the drawables or pass events to the drawables.</p>
<h2><a class="anchor" id="sigTut"></a>
Tutorial on the Usage of Signals</h2>
<p>We start with a very simple example of using a signal that takes a single integer parameter. One declares the signal according to </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cgv/base/signal.h&gt;</span></div>
<div class="line"></div>
<div class="line">signal&lt;int&gt; int_sig;</div>
</div><!-- fragment --><p> Next we want to attach callbacks to the signal, where in the simplest version the functions, methods or functors have the same signature (same number and type of parameters). Let us declare the following function and class type </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> int_func(<span class="keywordtype">int</span> i) { std::cout &lt;&lt; <span class="stringliteral">&quot;f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>X : <span class="keyword">public</span> cgv::base::tacker</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> int_method(<span class="keywordtype">int</span> i)   { std::cout &lt;&lt; <span class="stringliteral">&quot;X::m(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line">        <span class="keywordtype">void</span> operator () (<span class="keywordtype">int</span> i) { std::cout &lt;&lt; <span class="stringliteral">&quot;X(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">X x;</div>
</div><!-- fragment --><p> Now we have a function and a method that take one integer argument exactly like the signal. Instances of class <code>X</code> like <code>x</code> in our example also have the ()-operator overloaded with one integer argument. Thus these instances are at the same time functors and can be used as a function with one integer argument, i.e. <code>x(17)</code>.</p>
<p>Note that the class <code>X</code> is derived from cgv::base::tacker, which is important to avoid invalid pointers as explained below.</p>
<p>Next we want to attach our three different callbacks to the signal: </p>
<div class="fragment"><div class="line">connect(int_sig, int_func);</div>
<div class="line">connect(int_sig, &amp;x, &amp;X::int_method);</div>
<div class="line">connect(int_sig, x);</div>
</div><!-- fragment --><p> Note that when attaching a method of an instance to a signal, one has to provide the this pointer of the instance and the method pointer, which is specified in C++ with a leading &amp;-symbol followed by the class name, two colons and the method name.</p>
<p>After the attachment of callbacks we can send out a signal what can be interpreted as emitting an event. This is done by using the signal in exactly the same way as a function with an integer argument: </p>
<div class="fragment"><div class="line">int_sig(13);</div>
</div><!-- fragment --><p> what generates the following output to the std::cout stream </p>
<div class="fragment"><div class="line">f(13)</div>
<div class="line">X::m(13)</div>
<div class="line">X(13)</div>
</div><!-- fragment --><p>Similar to the attachment of callbacks with the cgv::base::connect function, one can detach a callback with cgv::base::disconnect according to </p>
<div class="fragment"><div class="line">disconnect(int_sig, int_func);</div>
<div class="line">disconnect(int_sig, &amp;x, &amp;X::int_method);</div>
<div class="line">disconnect(int_sig, x);</div>
</div><!-- fragment --><p> Note that when disconnecting a functor instance, all methods of the same instance attached to the signal as callback are detached as well.</p>
<p>Callbacks to methods of instances or functors bear the danger that the instance to which the signal was connected is destructed before the signal is emitted. In this case the signal would call a method or the ()-operator with an invalid this pointer.</p>
<p>To avoid this problem, all class that can be attached with a method or as functor to a signal, have to be derived from the cgv::base::tacker class, which registers all connections of the class instance to any signals and removes these connections on destruction of the instance. When a signal is then emitted it wont do a callback with invalid this pointer as the tacker class removed the callback from the signal.</p>
<p>Here a short example that relies on this functionality: </p>
<div class="fragment"><div class="line">{</div>
<div class="line">   X x1;</div>
<div class="line">   connect(int_sig, x1);</div>
<div class="line">}</div>
<div class="line">int_sig(11);</div>
</div><!-- fragment --><p> Signals with more than one argument work in exactly the same way. More difficult is the support for return values as these have to be combined from the return values of the different callbacks. The only return values supported in the cgv framework are of type bool. For boolean return values one can use logical operators to combine the return values of the callbacks. In the framework logical AND and OR are supported. One can further select between short circuit evaluation and full evaluation. The short circuit evaluation stopps performing callbacks as soon as the final return value cannot change anymore, i.e. as soon as the first callback returns false when logical AND is used for combining.</p>
<p>The support for signals with boolean return values is provided by the cgv::base::bool_signal template. The logical operator and whether short circuit evaluation should be used is specified as string argument in the constructor of the signal. The default choise is logical AND in the short circuit version. It follows a code example, where a boolean signal is used to check the validity of a value with the full boolean AND combining option. </p>
<div class="fragment"><div class="line">bool_signal&lt;int&gt; check_valid(<span class="stringliteral">&quot;+&amp;&quot;</span>); <span class="comment">// use &#39;+&#39;/&#39;*&#39; for full/short circuit eval</span></div>
<div class="line">                                    <span class="comment">// and &#39;&amp;&#39;/&#39;|&#39; for logical AND/OR combination</span></div>
<div class="line"><span class="keywordtype">bool</span> up_check(<span class="keywordtype">int</span> i)   { <span class="keywordflow">return</span> i &lt; 10; } </div>
<div class="line"><span class="keywordtype">bool</span> down_check(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i &gt; 3; }</div>
<div class="line"></div>
<div class="line">connect(check_valid, up_check);</div>
<div class="line">connect(check_valid, down_check);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (check_valid(7))</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;7 is valid&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The final feature supported in the signal mechanism of cgv is argument rebinding of the callbacks. Suppose you have a callback that has a different number or different types of arguments as the signal to which you want to attach the callback. This would typically require the implementation of an interface function with a signature matching that of the signal and an implementation that calls the callback with parameters derived from the parameters retrieved from the signal.</p>
<p>In cases where this conversion of parameters is simply the exclusion of one or several parameters, a rearrangement or the addition of a constant or reference to a variable, one can use the functions cgv::gui::rebind to generate a functor implementing the parameter conversion without the need for the declaration of a new function.</p>
<p>The functors returned by cgv::base::rebind overload the ()-operator with all possible signatures such that they can be attached to any signal. Currently, rebinding is only supported for function and methods and not for functors. In case of a function the first parameter to the rebind function is the function itself. In case of a method the first two parameters are the this pointer and the method pointer. Depending on the number of arguments in the signature of the rebound function / method, the rebind() functions takes one further parameter for each function / method argument. This argument can be one out of</p>
<ul>
<li>cgv::base::_0, _1, ..., _9 ... to specify the i-th parameter from the signal</li>
<li>cgv::base::_c(value) ... to specify a constant value</li>
<li>cgv::base::_r(variable) ... to specify a reference to a variable</li>
</ul>
<p>Here are some examples for rebinding with respect to the integer signal used in the examples before. </p>
<div class="fragment"><div class="line"><span class="comment">// ignore parameter from signal when calling a procedure without parameters </span></div>
<div class="line">rebind(proc,    int_sig);</div>
<div class="line"></div>
<div class="line"><span class="comment">// use constant string value for first argument and first parameter from</span></div>
<div class="line"><span class="comment">// signal for second parameter when calling a method from an instance y</span></div>
<div class="line"><span class="comment">// of type Y that takes a string and an int as parameters.</span></div>
<div class="line">rebind(y, &amp;Y::str_int_method, int_sig, _c(std::string(<span class="stringliteral">&quot;string argument&quot;</span>)), _0);</div>
</div><!-- fragment --><p>The rebind function finally returns a functor instance that could be attached to an arbitrary signal. As the returned functor is a temporary object, it would be destroyed after the connect function call has been evaluated. To avoid this, one uses the cgv::base::connect_copy() function instead of the cgv::base::connect() function when attaching a functor resulting from the cgv::base::rebind() function to the signals. This will cause the creation of a permanent copy of the functor.</p>
<p>One final pitfall should be mentioned: when rebinding to a method <code>m()</code> which is implemented in a base class <code>B</code> of the class <code>A</code>, the this pointer of type <code>A</code> has to be cast to the base type <code>B</code> when used in the rebind method, i.e. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B {</div>
<div class="line">   <span class="keywordtype">void</span> m(<span class="keywordtype">int</span> i);</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>A : <span class="keyword">public</span> B {</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">A a;</div>
<div class="line"></div>
<div class="line">connect_copy(int_sig, rebind(static_cast&lt;B*&gt;(&amp;a), &amp;B::m)</div>
</div><!-- fragment --><p> Thus you need to use type <code>B</code> to cast the this pointer as well as for specifying the method pointer.</p>
<p>Finally, one must note that the error messages generated by the compiler, when using signals are especially unreadable in case of wrong usage of the rebind functions. Please check your code against the explanation here to try to eliminate the error and dont try to understand the error message - or rather huge number of error messages. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 5 2019 15:06:49 for cgv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
